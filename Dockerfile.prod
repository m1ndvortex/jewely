# ============================================================================
# Production-Optimized Multi-Stage Dockerfile for Django Application
# ============================================================================
# This Dockerfile implements best practices for production deployments:
# - Multi-stage build to minimize final image size
# - Non-root user for security
# - Health checks for container orchestration
# - Optimized layer caching
# - Security hardening
# ============================================================================

# ============================================================================
# Stage 1: Builder - Install dependencies and compile packages
# ============================================================================
FROM python:3.11-slim as builder

# Set build-time environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Install build dependencies
# These will NOT be in the final image
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    g++ \
    python3-dev \
    musl-dev \
    libpq-dev \
    libffi-dev \
    libssl-dev \
    cargo \
    && rm -rf /var/lib/apt/lists/*

# Create virtual environment
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Copy and install Python dependencies
COPY requirements.txt /tmp/requirements.txt
RUN pip install --no-cache-dir --upgrade pip setuptools wheel && \
    pip install --no-cache-dir -r /tmp/requirements.txt
# Note: gunicorn is now in requirements.txt (version 23.0.0)

# ============================================================================
# Stage 2: Runtime - Create minimal production image
# ============================================================================
FROM python:3.11-slim as runtime

# Set runtime environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PATH="/opt/venv/bin:$PATH" \
    DJANGO_SETTINGS_MODULE=config.settings.production \
    PORT=8000

# Install only runtime dependencies (no build tools)
RUN apt-get update && apt-get install -y --no-install-recommends \
    postgresql-client \
    gettext \
    curl \
    procps \
    && rm -rf /var/lib/apt/lists/*

# Copy virtual environment from builder stage
COPY --from=builder /opt/venv /opt/venv

# Create non-root user and group
# Using specific UID/GID for consistency across environments
RUN groupadd -r -g 1000 appgroup && \
    useradd -r -u 1000 -g appgroup -m -s /bin/bash appuser

# Create application directories with proper permissions
RUN mkdir -p /app /app/staticfiles /app/media /app/logs && \
    chown -R appuser:appgroup /app

# Set working directory
WORKDIR /app

# Copy application code
# Use .dockerignore to exclude unnecessary files
COPY --chown=appuser:appgroup . /app/

# Switch to non-root user
USER appuser

# Collect static files
# Set minimal environment variables needed for collectstatic
ENV DJANGO_SETTINGS_MODULE=config.settings.production \
    SECRET_KEY=build-time-secret-key-exactly-fifty-characters-long-value-here \
    DJANGO_SECRET_KEY=build-time-secret-key-exactly-fifty-characters-long-value-here \
    POSTGRES_DB=dummy \
    POSTGRES_USER=dummy \
    POSTGRES_PASSWORD=dummy \
    POSTGRES_HOST=localhost \
    POSTGRES_PORT=5432 \
    SITE_URL=http://localhost:8000 \
    ALLOWED_HOSTS=* \
    DEBUG=False \
    REDIS_USE_SENTINEL=False \
    REDIS_URL=redis://localhost:6379/0 \
    DEFAULT_FROM_EMAIL=noreply@example.com \
    EMAIL_HOST=localhost \
    FIELD_ENCRYPTION_KEY=build-time-encryption-key-32chars-long \
    ALERT_WEBHOOK_TOKEN=build-time-webhook-token \
    COLLECTSTATIC_ONLY=1

# Run collectstatic with dummy database - ignore errors as files will still be collected
RUN python manage.py collectstatic --noinput 2>&1 | tail -5 || true; \
    if [ -d "/app/staticfiles/admin" ]; then \
        echo "âœ“ Static files collected successfully"; \
        ls -la /app/staticfiles/ | head -10; \
    else \
        echo "WARNING: Admin static files not found, but continuing..."; \
        mkdir -p /app/staticfiles; \
    fi

# CRITICAL: Unset COLLECTSTATIC_ONLY so runtime uses real database!
ENV COLLECTSTATIC_ONLY=""

# Compile translation messages
RUN python manage.py compilemessages || true

# Expose application port
EXPOSE 8000

# Configure health check
# This allows container orchestrators (Docker, Kubernetes) to monitor container health
HEALTHCHECK --interval=30s \
            --timeout=10s \
            --start-period=40s \
            --retries=3 \
    CMD curl -f http://localhost:8000/health/ || exit 1

# Production command using gunicorn
# Configuration:
# - 4 worker processes (adjust based on CPU cores: 2-4 x num_cores)
# - 2 threads per worker for handling concurrent requests
# - 120 second timeout for long-running requests
# - Access logs to stdout for container log aggregation
# - Error logs to stderr
# - Bind to 0.0.0.0:8000 to accept connections from outside container
CMD ["gunicorn", \
     "--bind", "0.0.0.0:8000", \
     "--workers", "4", \
     "--threads", "2", \
     "--timeout", "120", \
     "--access-logfile", "-", \
     "--error-logfile", "-", \
     "--log-level", "info", \
     "--worker-class", "sync", \
     "--worker-tmp-dir", "/dev/shm", \
     "config.wsgi:application"]

# ============================================================================
# Build and Run Instructions:
# ============================================================================
# Build:
#   docker build -f Dockerfile.prod -t jewelry-shop:latest .
#
# Run:
#   docker run -p 8000:8000 --env-file .env jewelry-shop:latest
#
# Build with BuildKit for better caching:
#   DOCKER_BUILDKIT=1 docker build -f Dockerfile.prod -t jewelry-shop:latest .
#
# Multi-platform build:
#   docker buildx build --platform linux/amd64,linux/arm64 \
#     -f Dockerfile.prod -t jewelry-shop:latest .
# ============================================================================
